#!/usr/bin/env bash

# All tests here are reusable per application
# Test HAS TO `return 1` in case it fails.
# If a function returns without specifying an exit/return code, it is assumed the test passed.

# Attempts to guess the port the application is running on using the nginx installers.
get_port() {
    appnginxconf="/etc/nginx/apps/$1.conf"
    installer="/etc/swizzin/scripts/nginx/$1.sh"
    if [ -f /install/.nginx.lock ] && [ -f "$appnginxconf" ] && grep -w "proxy_pass" "$appnginxconf" -q; then
        echo_log_only "Found compatible local nginx config for $1"
        port="$(grep -w "proxy_pass" "$appnginxconf" | sed 's/.*://; s/[^0-9].*//')"
    elif [ -f "$installer" ]; then
        echo_log_only "Trying to find port from installer of $1"
        port="$(grep -w "proxy_pass" "$installer" | sed 's/.*://; s/[^0-9].*//')"

    else
        echo_log_only "Neither config nor installer worked for guessing port for $1"
        # No installer for application found
        return 1
    fi

    #check if port returned is a normal number
    if [ "$port" -eq "$port" ] 2> /dev/null; then
        echo "$port"
    else
        return 1
    fi
}

# Attempts to verify that the service for an application specified by $1 is running.
check_service() {
    echo_log_only "Checking $1 service is active"
    systemctl -q is-active "$1" || {
        systemctl status "$1" >> $log 2>&1
        echo_warn "$1.service not active!"
        return 1
    }
}

# Attempts to verify that the reverse proxy configuration for an application accessible at https://localhost/$1  is accessible.
# $2 is optionally supplied to curl as extra parementers, e.g. basic auth
check_nginx() {
    if [ ! -f /install/.nginx.lock ]; then
        echo_warn "nginx not installed, cannot verify if $1 is reachable through it. Skipping."
        return
    fi

    extra_params="$2"
    echo_log_only "Checking if $1 is reachable via nginx"
    master="$(_get_master_username)"
    password="$(_get_user_password "$master")"
    curl --user "${master}:${password}" $extra_params -sSfLk https://127.0.0.1/"$1" -o /dev/null >> $log 2>&1 || {
        echo_warn "Querying https://127.0.0.1/$1 failed"
        return 1
    }
}

# Attempts to verify that an application accessible at http://localhost:$1  is accessible.
# If $1 is not a number sequence, the ports are guessed off of the application name supplied via $1
# $2 is optionally supplied to curl as extra parementers, e.g. basic auth
# $3 is optionally used as a baseurl to append to the location curl queries
# $4 is optionally used as the protocol to use instead of `http`
check_port_curl() {
    echo_log_only "Checking if port $1 is reachable via curl"
    if [ "$1" -eq "$1" ] 2> /dev/null; then
        port=$1
    else
        port=$(get_port "$1") || {
            echo_warn "Couldn't guess port of $1"
            return 1
        }
    fi
    extra_params="$2"
    if [ -f /install/.nginx.lock ]; then
        if [[ -n $3 ]]; then
            baseurl="$3"
        else
            if [ "$1" -eq "$1" ] 2> /dev/null; then
                : # TODO handle the case when the function just got the port number and not the name of the application
            fi
            baseurl="$1"
        fi
    fi
    #shellcheck disable=SC2086
    curl -sSfLk $extra_params ${4:-http://}127.0.0.1:"$port"/"$baseurl" -o /dev/null || {
        echo_warn "Querying ${4:-http://}127.0.0.1:$port/$baseurl failed"
        echo
        return 1
    }
}

# Attempts to verify that an application has opened and listens to the port $1 using `lsof`.
# If $1 is not a number sequence, the ports are guessed off of the application name supplied via $1
check_port() {
    echo_log_only "Checking if port $1 is open and listened to"
    if [ "$1" -eq "$1" ] 2> /dev/null; then
        port=$1
    else
        port=$(get_port "$1") || {
            echo_warn "Couldn't guess port of $1"
            return 1
        }
    fi

    lsof "-i:$port" >> $log 2>&1 || {
        echo_warn "Port $port does not seem to be open"
        return 1
    }

}

# based off the value of $BAD, returns an appropriate message and kills the test with an appropriate exit code.
evaluate_bad() {
    if [[ $BAD == "true" ]]; then
        echo_error "$1 did not pass tests"
        exit 1
    else
        echo_log_only "$1 passed all tests"
    fi
}
